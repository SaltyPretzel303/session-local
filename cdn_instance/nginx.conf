# user root;

# error_log /var/log/nginx/err_log.log notice;

events {
	use epoll;
	worker_connections 1024;
}

# Accept transcoded rtmp streams coming from the ingest rtmp server.
rtmp {
	server {
		listen 11000;

		application hls {

			live on;

			# Only accept publishing from cdn_proxy.
			# allow publish ;
			# deny publish all;
			# deny play all;
			# Deny playing rtmp stream ...

			# Package streams as HLS
			hls on;
			hls_path /var/www/live;
			hls_nested on;

			hls_fragment 2s;
			hls_playlist_length 12s;
			# wait_video on;
			# sync 50ms;
			# interleave on;
			# wait_key on;
			# hls_cleanup on; # default is on as well

			hls_fragment_naming system;

			# hls_datetime system; # doesn't work for some reason

			hls_keys on;
			hls_key_path /var/www/keys;
			hls_key_url /keys/;
			hls_fragments_per_key 10;

			on_publish http://session-cdn-manager:8004/add_media_server;
			on_publish_done http://session-cdn-manager:8004/remove_media_server;

		}
	}
}

# Server hsl stream to the viewers.
http {
	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	keepalive_timeout 65;
	types_hash_max_size 2048;
	include /etc/nginx/mime.types;

	# raw byte stream
	default_type application/octet-stream;

	server {
		listen 10000 default_server;
		server_name _;

		root /var/www;

		# add_header 'Access-Control-Allow-Origin' 'http://localhost' always;
		add_header 'Access-Control-Allow-Origin' 'http://localhost:3000' always;
		add_header 'Access-Control-Allow-Credentials' 'true' always;
		# add_header 'Access-Control-Allow-Credentials' 'true';
		# add_header 'Access-Control-Allow-Headers' 'X-Cookie';
		# add_header 'Access-Control-Allow-Headers' 'Cookie';
		# add_header 'Access-Control-Allow-Headers' 'RandomField';

		# It is assumed that the user is previousley authenticated and the
		# cookie_sessionId field is populated.
		# sha1 signature is calculated and passed back to the client requesting *.m3u8,
		# This (modified) URI is gonna be used for each subsequent request for *.ts file.
		location ~ ^/live/([^/]+)_([^/]+)/index\.m3u8$ {
			# resolver 127.0.0.11;
			expires -1d;
			set $stream_username $1;
			set $stream_quality $2;

			# NOTE Carefully with this approach, when using abr, each quality
			# of the same stream will have the same signature beacuse only
			# the streamer name is used to calculate sig.
			# Previously stream_quality is used for sig calculation and it worked
			# but it is never tested with the abr.

			# set_hmac_sha1 $sig "session_secret_key" "$cookie_session $stream_username";
			set_hmac_sha1 $sig "session_secret_key" "$stream_username";
			set_encode_base64 $sig $sig;

			subs_filter_types application/vnd.apple.mpegurl;

			# Note that $sig will have '=' at the end it is not the regex's fault.
			subs_filter "URI=\"/keys/([^/]+)/([0-9]+)\.key\"" "URI=\"/keys/$1/$2.key?s=$sig\"" gr;

			# proxy_pass http://printer:8010/$1/$cookie_session;
		}

		location ~ ^/keys/([^/]+)_([^/]+)/[0-9]+\.key$ {
			resolver 127.0.0.11;

			set $stream_username $1;
			set $stream_quality $2;
			set $user_sig $arg_s;

			# Can not just return 200 here, this path has to return encryption
			# key and that will happen only if auth_request result is 200
			# or there is no auth_request call.
			auth_request /authorize_key;
		}

		# Auth request proxy will contain stream_username and sessionId passed
		# from the original requst.
		# Backend is gonna match sesionId againts valid sessions and
		# provide user's data, populated once the user was authenticated.
		location = /authorize_key {
			resolver 127.0.0.11;
			internal;

			set_hmac_sha1 $sig 'session_secret_key' "$stream_username";
			set_encode_base64 $sig $sig;

			if ($sig != $user_sig) {
				return 403;
			}

			proxy_set_header X-Stream-Username $stream_username;

			# proxy_pass http://session-tokens-api:8100/verify;

			# ATTENTION everyone is authorized to consume every stream
			return 200;
			# Once the verify api gets fixed in tokens-api this call should
			# be redirected there.
			# proxy_pass http://session-auth:8003/authorize;
		}

		# Used by the cdn_manager to determine if the cdn instance is available.
		location /health_check {
			return 200;
		}
	}
}