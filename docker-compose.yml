version: '3.5'

networks: 
  session-net: 
    driver: bridge
    name: session-net
    # external: true

services:
  # client-gateway:
  #   container_name: session-client-gateway
  #   build:
  #     context: ./
  #     dockerfile: ./dockerfiles/client_gateway.Dockerfile
  #   image: session/client-gateway
  #   ports:
  #     - "0.0.0.0:8000:8000"
  #   networks: 
  #     - session-net
  #   stop_signal: SIGINT
    # Flask will quit the app on SIGINT. 
    # Docker (by default) sends SIGTERM and if that doesn't work 
    # SIGKILL will kill the process.

  nginx-rtmp: 
    build: 
      context: ./ 
      dockerfile: ./dockerfiles/nginx_rtmp.Dockerfile
    image: session/nginx-rtmp 

  frontend:
    container_name: session-frontend
    build: 
      context: ./
      dockerfile: ./dockerfiles/frontend.Dockerfile
    image: session/frontend
    ports:
      - "0.0.0.0:80:80"
      # - "0.0.0.0:3000:80"
    networks:
      - session-net
    stop_signal: SIGINT

  tokens-core: 
    container_name: session-tokens-core
    image: registry.supertokens.io/supertokens/supertokens-postgresql
    ports: 
      - "0.0.0.0:8030:3567"
    networks: 
      - session-net
    # stop_signal: SIGINT

  tokens-api:
    container_name: session-tokens-api
    build: 
      context: ./
      dockerfile: ./dockerfiles/tokens-api.Dockerfile
    image: session/tokens-api
    ports: 
      - "0.0.0.0:8100:8100"
    networks: 
      - session-net
    stop_signal: SIGINT

  # Will be replaced with the tokens-api.
  auth-service:
    container_name: session-auth
    build: 
      context: ./
      dockerfile: ./dockerfiles/auth_service.Dockerfile
    image: session/auth-service
    ports:
      - "0.0.0.0:8003:8003"
    networks:
      - session-net
    stop_signal: SIGINT
    # Flask will quit the app on SIGINT. 
    # Docker (by default) sends SIGTERM and if that doesn't work 
    # SIGKILL will kill the process.

  ingest-proxy:
    container_name: session-ingest-proxy
    build: 
      context: ./
      dockerfile: dockerfiles/ingest_proxy.Dockerfile
    image: session/ingest-proxy 
    ports:
      - 0.0.0.0:9000:9000
      - 0.0.0.0:9001:9999
    networks: 
      - session-net

  ingest-instance:
    container_name: session-ingest
    build:
      context: ./
      dockerfile: dockerfiles/ingest.Dockerfile
    image: session/ingest
    ports: 
      - "0.0.0.0:9090:9090"
      - "0.0.0.0:9080:9080"
      - "0.0.0.0:8080:8080"
    networks: 
      - session-net
    # volumes: 
    #   - ./ingest/nginx.config:/etc/nginx/nginx.conf

  stream-registry:
    container_name: session-stream-registry
    build: 
      context: ./
      dockerfile: ./dockerfiles/stream_registry.Dockerfile
    image: session/stream-registry
    ports:
      - "0.0.0.0:8002:8002"
    networks: 
      - session-net
    stop_signal: SIGINT
    # Flask will quit the app on SIGINT. 
    # Docker (by default) sends SIGTERM and if that doesn't work 
    # SIGKILL will kill the process.

  cdn-proxy:
    container_name: session-cdn-proxy
    build:
      context: ./
      dockerfile: ./dockerfiles/cdn_proxy.Dockerfile
    image: session/cdn-proxy
    ports:
      - "0.0.0.0:12000:12000"
    networks:
      - session-net

  cdn-instance:
    container_name: session-cdn
    build:
      context: ./
      dockerfile: ./dockerfiles/cdn_instance.Dockerfile
    image: session/cdn
    ports:
      - "0.0.0.0:11000:11000"
      - "0.0.0.0:10000:10000"
    networks:
      - session-net 

  cdn-manager:
    container_name: session-cdn-manager
    build:
      context: ./
      dockerfile: ./dockerfiles/cdn_manager.Dockerfile
    image: session/cdn-manager
    ports:
      - "0.0.0.0:8004:8004"
    networks:
      - session-net 

  registry-database:
    container_name: session-registry-db
    build: 
      context: ./
      dockerfile: ./dockerfiles/registry_db.Dockerfile
    image: session/registry-db
    ports: 
      - "0.0.0.0:27017:27017"
    networks: 
      - session-net

  # Will be repalced with the tokens-db.
  auth-database:
    container_name: session-auth-db
    build: 
      context: ./ 
      dockerfile: ./dockerfiles/auth_db.Dockerfile
    image: session/auth-db
    ports: 
      - "0.0.0.0:37017:27017"
    networks: 
      - session-net

  # Note: If you are assigning a custom name to your db service on the line below, 
  # make sure it does not contain underscores
  tokens-db:
    container_name: session-tokens-db
    image: 'postgres:latest'
    environment:
      POSTGRES_USER: supertokens_user 
      POSTGRES_PASSWORD: somePassword 
      POSTGRES_DB: supertokens
    ports:
      - 5432:5432
    networks:
      - session-net
    # restart: unless-stopped
    healthcheck:
      test: ['CMD', 'pg_isready', '-U', 'supertokens_user', '-d', 'supertokens']
      interval: 5s
      timeout: 5s
      retries: 5

  tokens-core:
    container_name: session-tokens-core
    image: registry.supertokens.io/supertokens/supertokens-postgresql:7.0
    depends_on:
      tokens-db:
        condition: service_healthy
    ports:
      - 3567:3567
    environment:
      POSTGRESQL_CONNECTION_URI: "postgresql://supertokens_user:somePassword@session-tokens-db:5432/supertokens"
    networks:
      - session-net
    # restart: unless-stopped
    healthcheck:
      test: >
        bash -c 'exec 3<>/dev/tcp/127.0.0.1/3567 && echo -e "GET /hello HTTP/1.1\r\nhost: 127.0.0.1:3567\r\nConnection: close\r\n\r\n" >&3 && cat <&3 | grep "Hello"'
      interval: 10s
      timeout: 5s
      retries: 5

  tokens-api: 
    container_name: session-tokens-api
    build:
      context: ./
      dockerfile: ./dockerfiles/tokens-api.Dockerfile
    image: session/tokens-api
    ports: 
      - "0.0.0.0:8100:8100"
    networks: 
      - session-net
    stop_signal: SIGINT


  # Api for printing headers, cookies and request payload 
  #  used just for debugging 
  printer: 
    container_name: printer
    build:
      context: ./
      dockerfile: ./dockerfiles/printer.Dockerfile
    image: session/printer
    ports:
      - "0.0.0.0:8010:8010"
    networks:
      - session-net
    stop_signal: SIGINT
  
  streamer: 
    container_name: streamer
    build: 
      context: ./
      dockerfile: ./dockerfiles/streamer.Dockerfile
    image: session/streamer
    
    networks: 
      - session-net
    stop_signal: SIGINT

    